<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AWE2M8 Test Suite</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(-45deg, #0a0a0a, #001a00, #003300, #0a0a0a);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            color: white;
            padding: 20px;
            min-height: 100vh;
        }

        @keyframes gradientShift {

            0%,
            100% {
                background-position: 0% 50%;
            }

            50% {
                background-position: 100% 50%;
            }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #ffffff;
            font-size: 2.5rem;
            text-shadow: 0 0 30px rgba(0, 255, 0, 0.3);
            font-weight: 800;
        }

        .subtitle {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 30px;
            font-size: 0.9rem;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        button {
            padding: 15px 40px;
            background: linear-gradient(135deg, #00ff00, #00cc00);
            color: #000;
            border: none;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 0, 0.3);
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 255, 0, 0.5);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .summary {
            background: rgba(0, 255, 0, 0.05);
            border: 1px solid rgba(0, 255, 0, 0.2);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .summary-item {
            text-align: center;
        }

        .summary-number {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 5px;
        }

        .summary-number.pass {
            color: #00ff00;
        }

        .summary-number.fail {
            color: #ff4444;
        }

        .summary-number.warn {
            color: #ffaa00;
        }

        .summary-number.total {
            color: #ffffff;
        }

        .summary-label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9rem;
        }

        .test-category {
            background: rgba(0, 255, 0, 0.05);
            border: 1px solid rgba(0, 255, 0, 0.2);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .category-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            cursor: pointer;
        }

        .category-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #00ff00;
        }

        .category-status {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        .category-status.passed {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
        }

        .category-status.failed {
            background: rgba(255, 0, 0, 0.2);
            color: #ff4444;
        }

        .category-status.warning {
            background: rgba(255, 170, 0, 0.2);
            color: #ffaa00;
        }

        .category-status.running {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
        }

        .test-results {
            display: none;
        }

        .test-results.show {
            display: block;
        }

        .test-item {
            background: rgba(0, 0, 0, 0.3);
            border-left: 4px solid;
            padding: 12px 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .test-item.pass {
            border-color: #00ff00;
        }

        .test-item.fail {
            border-color: #ff4444;
        }

        .test-item.warn {
            border-color: #ffaa00;
        }

        .test-name {
            flex: 1;
        }

        .test-status {
            font-weight: 600;
            padding: 3px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
        }

        .test-status.pass {
            background: rgba(0, 255, 0, 0.2);
            color: #00ff00;
        }

        .test-status.fail {
            background: rgba(255, 0, 0, 0.2);
            color: #ff4444;
        }

        .test-status.warn {
            background: rgba(255, 170, 0, 0.2);
            color: #ffaa00;
        }

        .test-details {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.7);
        }

        .test-error {
            color: #ff4444;
            margin-top: 5px;
            font-family: monospace;
            font-size: 0.8rem;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #00cc00);
            width: 0%;
            transition: width 0.3s ease;
        }

        .export-section {
            text-align: center;
            margin-top: 30px;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .summary {
                grid-template-columns: 1fr 1fr;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>üß™ AWE2M8 Test Suite</h1>
        <p class="subtitle">Pre-commit validation & health check</p>

        <div class="controls">
            <button id="runAllTests">‚ñ∂Ô∏è Run All Tests</button>
            <button id="runQuickTests">‚ö° Quick Tests Only</button>
            <button id="exportReport" disabled>üìÑ Export Report</button>
            <button id="clearResults">üóëÔ∏è Clear Results</button>
        </div>

        <div class="progress-bar hidden" id="progressBar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div class="summary hidden" id="summary">
            <div class="summary-item">
                <div class="summary-number total" id="totalTests">0</div>
                <div class="summary-label">Total Tests</div>
            </div>
            <div class="summary-item">
                <div class="summary-number pass" id="passedTests">0</div>
                <div class="summary-label">Passed</div>
            </div>
            <div class="summary-item">
                <div class="summary-number fail" id="failedTests">0</div>
                <div class="summary-label">Failed</div>
            </div>
            <div class="summary-item">
                <div class="summary-number warn" id="warningTests">0</div>
                <div class="summary-label">Warnings</div>
            </div>
        </div>

        <div id="testResults"></div>

        <div class="export-section hidden" id="exportSection">
            <p style="color: rgba(255, 255, 255, 0.6); margin-bottom: 10px;">
                ‚úì All critical tests passed. Safe to commit!
            </p>
        </div>
    </div>

    <script>
        // Test Configuration
        const testConfig = {
            contentJsonPaths: [
                '../content/content.json',
                './content/content.json',
                '/content/content.json',
                'content.json'
            ],
            requiredIndustries: ['fireSafety', 'gyms'],
            requiredDemos: ['voiceAI', 'aiReceptionist', 'databaseReactivation'],
            criticalFields: {
                industry: ['pageTitle', 'heroTitle', 'heroSubtitle', 'solution1Title', 'smsAgentDemoUrl'],
                demo: ['title', 'emoji', 'heroDescription']
            }
        };

        // Test Results Storage
        let testResults = {
            categories: [],
            total: 0,
            passed: 0,
            failed: 0,
            warnings: 0
        };

        // Test Categories
        const testCategories = [
            {
                name: 'JSON Structure Tests',
                quick: true,
                tests: [
                    { name: 'content.json exists and is accessible', fn: testContentJsonExists },
                    { name: 'JSON is valid and parseable', fn: testJsonValid },
                    { name: 'Required top-level structure exists', fn: testTopLevelStructure },
                    { name: 'Industries object exists', fn: testIndustriesExists },
                    { name: 'Required industries are present', fn: testRequiredIndustries }
                ]
            },
            {
                name: 'Data Integrity Tests',
                quick: true,
                tests: [
                    { name: 'All industry pages have required fields', fn: testIndustryFields },
                    { name: 'All URLs are valid format', fn: testUrlFormats },
                    { name: 'No empty critical fields', fn: testNoEmptyFields },
                    { name: 'Emoji fields contain valid emojis', fn: testEmojiFields }
                ]
            },
            {
                name: 'Link Validation Tests',
                quick: false,
                tests: [
                    { name: 'SMS demo links are accessible', fn: testSmsLinksAccessible },
                    { name: 'Orb iframe URLs are valid', fn: testOrbUrlsValid },
                    { name: 'Video URLs are accessible', fn: testVideoUrls }
                ]
            },
            {
                name: 'HTML File Tests',
                quick: true,
                tests: [
                    { name: 'Fire Safety HTML has required IDs', fn: testFireSafetyHtmlIds },
                    { name: 'Content editor HTML structure is valid', fn: testContentEditorStructure }
                ]
            },
            {
                name: 'Integration Tests',
                quick: false,
                tests: [
                    { name: 'Fire Safety page loads content correctly', fn: testFireSafetyIntegration },
                    { name: 'Content editor can read JSON', fn: testContentEditorIntegration }
                ]
            }
        ];

        let contentData = null;

        // ===== TEST IMPLEMENTATIONS =====

        async function testContentJsonExists() {
            for (const path of testConfig.contentJsonPaths) {
                try {
                    const response = await fetch(path);
                    if (response.ok) {
                        contentData = await response.json();
                        return { pass: true, message: `Found at: ${path}` };
                    }
                } catch (error) {
                    // Continue to next path
                }
            }
            return { pass: false, message: 'content.json not found in any expected location' };
        }

        async function testJsonValid() {
            if (!contentData) {
                return { pass: false, message: 'No JSON data loaded' };
            }
            try {
                JSON.stringify(contentData);
                return { pass: true, message: 'JSON is valid' };
            } catch (error) {
                return { pass: false, message: `JSON parse error: ${error.message}` };
            }
        }

        async function testTopLevelStructure() {
            if (!contentData) {
                return { pass: false, message: 'No data to test' };
            }
            const hasContent = Object.keys(contentData).length > 0;
            return {
                pass: hasContent,
                message: hasContent ? `${Object.keys(contentData).length} top-level keys found` : 'No content found'
            };
        }

        async function testIndustriesExists() {
            if (!contentData) {
                return { pass: false, message: 'No data to test' };
            }
            const exists = contentData.industries && typeof contentData.industries === 'object';
            return {
                pass: exists,
                message: exists ? 'Industries object found' : 'Industries object missing'
            };
        }

        async function testRequiredIndustries() {
            if (!contentData || !contentData.industries) {
                return { pass: false, message: 'No industries data' };
            }
            const missing = testConfig.requiredIndustries.filter(ind => !contentData.industries[ind]);
            if (missing.length > 0) {
                return { pass: false, message: `Missing industries: ${missing.join(', ')}` };
            }
            return { pass: true, message: `All ${testConfig.requiredIndustries.length} required industries present` };
        }

        async function testIndustryFields() {
            if (!contentData || !contentData.industries) {
                return { pass: false, message: 'No industries data' };
            }
            const issues = [];
            for (const [industryName, industryData] of Object.entries(contentData.industries)) {
                for (const field of testConfig.criticalFields.industry) {
                    if (!industryData[field]) {
                        issues.push(`${industryName}.${field} is missing`);
                    }
                }
            }
            if (issues.length > 0) {
                return { pass: false, message: issues.join(', '), warning: issues.length < 3 };
            }
            return { pass: true, message: 'All critical fields present' };
        }

        async function testUrlFormats() {
            if (!contentData) {
                return { pass: false, message: 'No data to test' };
            }
            const urlPattern = /^https?:\/\/.+/;
            const issues = [];

            function checkUrls(obj, path = '') {
                for (const [key, value] of Object.entries(obj)) {
                    if (key.toLowerCase().includes('url') && value && typeof value === 'string' && value !== '') {
                        if (!urlPattern.test(value)) {
                            issues.push(`${path}.${key}: "${value}" is not a valid URL`);
                        }
                    } else if (typeof value === 'object' && value !== null) {
                        checkUrls(value, path ? `${path}.${key}` : key);
                    }
                }
            }

            checkUrls(contentData);

            if (issues.length > 0) {
                return { pass: false, message: issues.slice(0, 3).join('; '), warning: true };
            }
            return { pass: true, message: 'All URL formats are valid' };
        }

        async function testNoEmptyFields() {
            if (!contentData) {
                return { pass: false, message: 'No data to test' };
            }
            const emptyFields = [];

            function checkEmpty(obj, path = '') {
                for (const [key, value] of Object.entries(obj)) {
                    const currentPath = path ? `${path}.${key}` : key;
                    if (typeof value === 'string' && value.trim() === '') {
                        emptyFields.push(currentPath);
                    } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        checkEmpty(value, currentPath);
                    }
                }
            }

            checkEmpty(contentData);

            if (emptyFields.length > 0) {
                return { pass: false, message: `${emptyFields.length} empty fields found`, warning: true };
            }
            return { pass: true, message: 'No empty fields detected' };
        }

        async function testEmojiFields() {
            if (!contentData) {
                return { pass: false, message: 'No data to test' };
            }
            const emojiPattern = /\p{Emoji}/u;
            const issues = [];

            for (const [key, value] of Object.entries(contentData)) {
                if (value && value.emoji && !emojiPattern.test(value.emoji)) {
                    issues.push(`${key}.emoji is not a valid emoji`);
                }
            }

            if (issues.length > 0) {
                return { pass: false, message: issues.join(', '), warning: true };
            }
            return { pass: true, message: 'All emoji fields valid' };
        }

        async function testSmsLinksAccessible() {
            if (!contentData || !contentData.industries) {
                return { pass: false, message: 'No industries data' };
            }
            const issues = [];
            for (const [name, data] of Object.entries(contentData.industries)) {
                if (data.smsAgentDemoUrl) {
                    try {
                        const response = await fetch(data.smsAgentDemoUrl, { method: 'HEAD', mode: 'no-cors' });
                        // Note: With no-cors, we can't check status, but at least we verify URL format
                    } catch (error) {
                        issues.push(`${name}: ${error.message}`);
                    }
                }
            }
            return { pass: true, message: 'SMS links format checked (full accessibility requires server)', warning: true };
        }

        async function testOrbUrlsValid() {
            if (!contentData) {
                return { pass: false, message: 'No data to test' };
            }
            const orbUrlPattern = /iframes\.ai/;
            const issues = [];

            function checkOrbUrls(obj, path = '') {
                for (const [key, value] of Object.entries(obj)) {
                    if (key.toLowerCase().includes('orb') && key.toLowerCase().includes('url') && value) {
                        if (!orbUrlPattern.test(value)) {
                            issues.push(`${path}.${key} doesn't appear to be a valid Orb URL`);
                        }
                    } else if (typeof value === 'object' && value !== null) {
                        checkOrbUrls(value, path ? `${path}.${key}` : key);
                    }
                }
            }

            checkOrbUrls(contentData);

            if (issues.length > 0) {
                return { pass: false, message: issues.join('; '), warning: true };
            }
            return { pass: true, message: 'All Orb URLs appear valid' };
        }

        async function testVideoUrls() {
            if (!contentData) {
                return { pass: false, message: 'No data to test' };
            }
            const videoUrlPattern = /(youtube\.com|youtu\.be|vimeo\.com|drive\.google\.com)/;
            let videoCount = 0;

            function countVideos(obj) {
                for (const [key, value] of Object.entries(obj)) {
                    if (key.toLowerCase().includes('video') && key.toLowerCase().includes('url') && value) {
                        videoCount++;
                    } else if (typeof value === 'object' && value !== null) {
                        countVideos(value);
                    }
                }
            }

            countVideos(contentData);

            return { pass: true, message: `${videoCount} video URLs found`, warning: videoCount === 0 };
        }

        async function testFireSafetyHtmlIds() {
            // This would need actual HTML file access
            // For now, we'll return a placeholder
            return { pass: true, message: 'HTML ID check requires file system access', warning: true };
        }

        async function testContentEditorStructure() {
            return { pass: true, message: 'Editor structure check requires file system access', warning: true };
        }

        async function testFireSafetyIntegration() {
            if (!contentData || !contentData.industries || !contentData.industries.fireSafety) {
                return { pass: false, message: 'Fire Safety data missing' };
            }
            const fs = contentData.industries.fireSafety;
            const hasRequiredFields = fs.heroTitle && fs.smsAgentDemoUrl && fs.solution1Title;
            return {
                pass: hasRequiredFields,
                message: hasRequiredFields ? 'Fire Safety integration ready' : 'Missing required Fire Safety fields'
            };
        }

        async function testContentEditorIntegration() {
            if (!contentData) {
                return { pass: false, message: 'Cannot test without JSON data' };
            }
            return { pass: true, message: 'JSON is readable by editor' };
        }

        // ===== TEST RUNNER =====

        async function runTests(quickOnly = false) {
            // Reset
            testResults = { categories: [], total: 0, passed: 0, failed: 0, warnings: 0 };
            contentData = null;

            const resultsContainer = document.getElementById('testResults');
            resultsContainer.innerHTML = '';

            document.getElementById('summary').classList.remove('hidden');
            document.getElementById('progressBar').classList.remove('hidden');
            document.getElementById('exportSection').classList.add('hidden');

            const categoriesToRun = quickOnly
                ? testCategories.filter(cat => cat.quick)
                : testCategories;

            const totalTests = categoriesToRun.reduce((sum, cat) => sum + cat.tests.length, 0);
            let completedTests = 0;

            for (const category of categoriesToRun) {
                const categoryResult = await runCategory(category, (progress) => {
                    completedTests++;
                    updateProgress(completedTests, totalTests);
                });
                testResults.categories.push(categoryResult);
            }

            updateSummary();
            document.getElementById('progressBar').classList.add('hidden');
            document.getElementById('exportReport').disabled = false;

            if (testResults.failed === 0) {
                document.getElementById('exportSection').classList.remove('hidden');
            }
        }

        async function runCategory(category, onProgress) {
            const categoryDiv = document.createElement('div');
            categoryDiv.className = 'test-category';
            categoryDiv.innerHTML = `
                <div class="category-header">
                    <div class="category-title">${category.name}</div>
                    <div class="category-status running">Running...</div>
                </div>
                <div class="test-results"></div>
            `;
            document.getElementById('testResults').appendChild(categoryDiv);

            const resultsDiv = categoryDiv.querySelector('.test-results');
            const statusDiv = categoryDiv.querySelector('.category-status');

            const results = {
                name: category.name,
                passed: 0,
                failed: 0,
                warnings: 0,
                tests: []
            };

            for (const test of category.tests) {
                const result = await test.fn();
                testResults.total++;

                let status = 'pass';
                if (!result.pass) {
                    status = result.warning ? 'warn' : 'fail';
                    if (result.warning) {
                        results.warnings++;
                        testResults.warnings++;
                    } else {
                        results.failed++;
                        testResults.failed++;
                    }
                } else {
                    if (result.warning) {
                        results.warnings++;
                        testResults.warnings++;
                        status = 'warn';
                    } else {
                        results.passed++;
                        testResults.passed++;
                    }
                }

                results.tests.push({ name: test.name, ...result, status });

                const testDiv = document.createElement('div');
                testDiv.className = `test-item ${status}`;
                testDiv.innerHTML = `
                    <div class="test-name">
                        ${test.name}
                        ${result.message ? `<div class="test-details">${result.message}</div>` : ''}
                    </div>
                    <div class="test-status ${status}">
                        ${status === 'pass' ? '‚úì PASS' : status === 'warn' ? '‚ö† WARN' : '‚úó FAIL'}
                    </div>
                `;
                resultsDiv.appendChild(testDiv);

                onProgress();
            }

            // Update category status
            let categoryStatus = 'passed';
            if (results.failed > 0) categoryStatus = 'failed';
            else if (results.warnings > 0) categoryStatus = 'warning';

            statusDiv.className = `category-status ${categoryStatus}`;
            statusDiv.textContent = `${results.passed}/${category.tests.length} passed`;

            resultsDiv.classList.add('show');

            // Make category collapsible
            categoryDiv.querySelector('.category-header').addEventListener('click', () => {
                resultsDiv.classList.toggle('show');
            });

            return results;
        }

        function updateProgress(completed, total) {
            const percent = (completed / total) * 100;
            document.getElementById('progressFill').style.width = `${percent}%`;
        }

        function updateSummary() {
            document.getElementById('totalTests').textContent = testResults.total;
            document.getElementById('passedTests').textContent = testResults.passed;
            document.getElementById('failedTests').textContent = testResults.failed;
            document.getElementById('warningTests').textContent = testResults.warnings;
        }

        function exportReport() {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const report = {
                timestamp: new Date().toISOString(),
                summary: {
                    total: testResults.total,
                    passed: testResults.passed,
                    failed: testResults.failed,
                    warnings: testResults.warnings,
                    passRate: ((testResults.passed / testResults.total) * 100).toFixed(2) + '%'
                },
                categories: testResults.categories
            };

            const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `test-report-${timestamp}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function clearResults() {
            document.getElementById('testResults').innerHTML = '';
            document.getElementById('summary').classList.add('hidden');
            document.getElementById('exportSection').classList.add('hidden');
            document.getElementById('exportReport').disabled = true;
            testResults = { categories: [], total: 0, passed: 0, failed: 0, warnings: 0 };
        }

        // Event Listeners
        document.getElementById('runAllTests').addEventListener('click', () => runTests(false));
        document.getElementById('runQuickTests').addEventListener('click', () => runTests(true));
        document.getElementById('exportReport').addEventListener('click', exportReport);
        document.getElementById('clearResults').addEventListener('click', clearResults);
    </script>
</body>

</html>

#!/usr/bin/env node

/**
* AWE2M8 Test Suite - Updated with Partners Support
* Tests ALL HTML files in agents/, industries/, partners/
* Usage: node test-runner.js [--quick]
*/

const fs = require('fs');
const path = require('path');

// ANSI color codes
const colors = {
reset: '\x1b[0m',
bright: '\x1b[1m',
green: '\x1b[32m',
red: '\x1b[31m',
yellow: '\x1b[33m',
blue: '\x1b[34m',
cyan: '\x1b[36m'
};

// Test Configuration
const config = {
contentJsonPath: './content/content.json',
requiredIndustries: ['fireSafety', 'gyms'],
requiredDemos: ['voiceAI', 'aiReceptionist', 'databaseReactivation'],
requiredPartners: ['rayWhiteUpperNorthShore'], // NEW: Required partner pages
criticalFields: {
industry: ['pageTitle', 'heroTitle', 'heroSubtitle', 'solution1Title', 'smsAgentDemoUrl'],
demo: ['title', 'emoji', 'heroDescription'],
partner: ['title', 'emoji', 'heroDescription', 'pageTitle'] // NEW: Partner required fields
},
// Folders to validate
requiredFolders: ['content', 'industries', 'agents'],
optionalFolders: ['partners', 'css', 'js', 'images'],
// Expected core files
expectedFiles: {
'content/content.json': 'Content JSON file',
'content-editor.html': 'Content editor'
},
// Partner HTML file mappings
partnerHtmlFiles: {
'rayWhiteUpperNorthShore': 'partners/raywhite-realestate.html'
}
};

let contentData = null;
let testResults = {
total: 0,
passed: 0,
failed: 0,
warnings: 0,
categories: []
};

// ===== UTILITY FUNCTIONS =====

function log(message, color = 'reset') {
console.log(`${colors[color]}${message}${colors.reset}`);
}

function printHeader() {
console.log('');
log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'cyan');
log(' üß™ AWE2M8 Test Suite - CLI Version ', 'bright');
log(' üìÅ Testing ALL HTML Files in All Folders ', 'cyan');
log(' ‚ú® Now with Partners Support! ‚ú® ', 'cyan');
log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'cyan');
console.log('');
}

function printSummary() {
console.log('');
log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê TEST SUMMARY ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'cyan');
console.log('');
log(`Total Tests: ${testResults.total}`, 'bright');
log(`‚úì Passed: ${testResults.passed}`, 'green');
log(`‚úó Failed: ${testResults.failed}`, 'red');
log(`‚ö† Warnings: ${testResults.warnings}`, 'yellow');
console.log('');

const passRate = ((testResults.passed / testResults.total) * 100).toFixed(1);
log(`Pass Rate: ${passRate}%`, passRate >= 90 ? 'green' : passRate >= 70 ? 'yellow' : 'red');
console.log('');

if (testResults.failed === 0) {
log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'green');
log(' ‚úì‚úì‚úì ALL CRITICAL TESTS PASSED - SAFE TO COMMIT ‚úì‚úì‚úì ', 'green');
log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'green');
return 0;
} else {
log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'red');
log(' ‚úó‚úó‚úó CRITICAL TESTS FAILED - DO NOT COMMIT ‚úó‚úó‚úó ', 'red');
log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'red');
return 1;
}
}

function printCategoryHeader(name) {
console.log('');
log(`‚ñº ${name}`, 'blue');
}

function printTestResult(name, result) {
const icon = result.pass ? (result.warning ? '‚ö†' : '‚úì') : '‚úó';
const color = result.pass ? (result.warning ? 'yellow' : 'green') : 'red';

log(` ${icon} ${name}`, color);
if (result.message) {
console.log(` ‚Üí ${result.message}`);
}
}

// ===== COMPREHENSIVE HTML VALIDATION =====

function testAgentsHtmlFilesExist() {
if (!fs.existsSync('agents')) {
return {
pass: false,
message: 'Agents folder does not exist'
};
}

const htmlFiles = fs.readdirSync('agents').filter(f => f.endsWith('.html'));

if (htmlFiles.length === 0) {
return {
pass: false,
message: 'Agents folder exists but contains no HTML files'
};
}

return {
pass: true,
message: `Found ${htmlFiles.length} HTML files in agents/ folder`
};
}

function testAllAgentsFilesValid() {
if (!fs.existsSync('agents')) {
return { pass: false, message: 'Agents folder missing' };
}

const htmlFiles = fs.readdirSync('agents').filter(f => f.endsWith('.html'));
const issues = [];
let validFiles = 0;

for (const file of htmlFiles) {
const filePath = path.join('agents', file);
try {
const content = fs.readFileSync(filePath, 'utf8');

// Check for basic HTML structure
const hasDoctype = content.includes('<!DOCTYPE') || content.includes('<!doctype'); const
    hasHtml=content.includes('<html') || content.includes('<HTML'); const hasHead=content.includes('<head') ||
    content.includes('<HEAD'); const hasBody=content.includes('<body') || content.includes('<BODY'); if (!hasDoctype &&
    !hasHtml) { issues.push(`${file}: Missing DOCTYPE and html tags`); } else if (content.length < 50) {
    issues.push(`${file}: File too short (${content.length} chars)`); } else { validFiles++; } } catch (error) {
    issues.push(`${file}: Cannot read - ${error.message}`); } } if (issues.length> 0) {
    return {
    pass: false,
    warning: validFiles > 0,
    message: `${issues.length}/${htmlFiles.length} files have issues: ${issues.slice(0, 3).join('; ')}${issues.length >
    3 ? '...' : ''}`
    };
    }

    return {
    pass: true,
    message: `All ${validFiles} agent HTML files are valid`
    };
    }

    function testIndustriesHtmlFilesExist() {
    if (!fs.existsSync('industries')) {
    return {
    pass: false,
    message: 'Industries folder does not exist'
    };
    }

    const htmlFiles = fs.readdirSync('industries').filter(f => f.endsWith('.html'));

    if (htmlFiles.length === 0) {
    return {
    pass: false,
    message: 'Industries folder exists but contains no HTML files'
    };
    }

    return {
    pass: true,
    message: `Found ${htmlFiles.length} HTML files in industries/ folder`
    };
    }

    function testAllIndustriesFilesValid() {
    if (!fs.existsSync('industries')) {
    return { pass: false, message: 'Industries folder missing' };
    }

    const htmlFiles = fs.readdirSync('industries').filter(f => f.endsWith('.html'));
    const issues = [];
    let validFiles = 0;

    for (const file of htmlFiles) {
    const filePath = path.join('industries', file);
    try {
    const content = fs.readFileSync(filePath, 'utf8');

    if (!content.includes('<!DOCTYPE') && !content.includes('<html')) { issues.push(`${file}: Missing DOCTYPE or html
        tag`); } else if (content.length < 50) { issues.push(`${file}: File too short`); } else { validFiles++; } }
        catch (error) { issues.push(`${file}: Cannot read`); } } if (issues.length> 0) {
        return {
        pass: false,
        warning: validFiles > 0,
        message: `${issues.length}/${htmlFiles.length} files have issues`
        };
        }

        return {
        pass: true,
        message: `All ${validFiles} industry HTML files are valid`
        };
        }

        // ===== NEW PARTNER TESTS =====

        function testPartnersFolder() {
        if (!fs.existsSync('partners')) {
        return {
        pass: false,
        message: 'Partners folder does not exist - create it to add partner pages'
        };
        }

        const htmlFiles = fs.readdirSync('partners').filter(f => f.endsWith('.html'));

        if (htmlFiles.length === 0) {
        return {
        pass: false,
        warning: true,
        message: 'Partners folder exists but contains no HTML files'
        };
        }

        return {
        pass: true,
        message: `Partners folder exists with ${htmlFiles.length} HTML file(s)`
        };
        }

        function testPartnersHtmlFilesValid() {
        if (!fs.existsSync('partners')) {
        return { pass: false, message: 'Partners folder missing' };
        }

        const htmlFiles = fs.readdirSync('partners').filter(f => f.endsWith('.html'));

        if (htmlFiles.length === 0) {
        return {
        pass: false,
        warning: true,
        message: 'No HTML files in partners folder'
        };
        }

        const issues = [];
        let validFiles = 0;

        for (const file of htmlFiles) {
        const filePath = path.join('partners', file);
        try {
        const content = fs.readFileSync(filePath, 'utf8');

        if (!content.includes('<!DOCTYPE') && !content.includes('<html')) { issues.push(`${file}: Missing DOCTYPE or
            html tag`); } else if (content.length < 50) { issues.push(`${file}: File too short`); } else { validFiles++;
            } } catch (error) { issues.push(`${file}: Cannot read`); } } if (issues.length> 0) {
            return {
            pass: false,
            warning: validFiles > 0,
            message: `${issues.length}/${htmlFiles.length} partner files have issues`
            };
            }

            return {
            pass: true,
            message: `All ${validFiles} partner HTML file(s) are valid`
            };
            }

            function testRayWhitePageExists() {
            const expectedPath = config.partnerHtmlFiles.rayWhiteUpperNorthShore;

            if (!fs.existsSync(expectedPath)) {
            return {
            pass: false,
            message: `Ray White page not found at: ${expectedPath}`
            };
            }

            try {
            const content = fs.readFileSync(expectedPath, 'utf8');

            if (content.length < 100) { return { pass: false, warning: true,
                message: 'Ray White HTML file exists but appears incomplete' }; } return { pass: true, message: `Ray
                White page exists at ${expectedPath}` }; } catch (error) { return { pass: false, message: `Cannot read
                Ray White page: ${error.message}` }; } } function testPartnersInContentJson() { if (!contentData) {
                return { pass: false, message: 'No JSON data loaded' }; } if (!contentData.partners) { return { pass:
                false, message: 'Partners section missing from content.json' }; } if (typeof contentData.partners
                !=='object' ) { return { pass: false, message: 'Partners section exists but is not an object' }; } const
                partnerCount=Object.keys(contentData.partners).length; return { pass: true, message: `Partners section
                exists with ${partnerCount} partner(s)` }; } function testRayWhiteInContentJson() { if (!contentData ||
                !contentData.partners) { return { pass: false, message: 'No partners data in JSON' }; } if
                (!contentData.partners.rayWhiteUpperNorthShore) { return { pass: false,
                message: 'rayWhiteUpperNorthShore missing from content.json partners section' }; } return { pass: true,
                message: 'Ray White entry exists in content.json' }; } function testPartnerFields() { if (!contentData
                || !contentData.partners) { return { pass: false, message: 'No partners data' }; } const issues=[]; for
                (const [partnerName, partnerData] of Object.entries(contentData.partners)) { for (const field of
                config.criticalFields.partner) { if (!partnerData[field] || partnerData[field].trim()==='' ) {
                issues.push(`${partnerName}.${field}`); } } } if (issues.length> 0) {
                return {
                pass: false,
                message: `Missing/empty partner fields: ${issues.slice(0, 3).join(', ')}${issues.length > 3 ? `
                (+${issues.length - 3} more)` : ''}`,
                warning: issues.length < 3 }; } return { pass: true, message: `All
                    ${Object.keys(contentData.partners).length} partner(s) have required fields` }; } //=====EXISTING
                    TESTS=====function testRequiredFoldersExist() { const missing=[]; const found=[]; for (const folder
                    of config.requiredFolders) { if (fs.existsSync(folder) && fs.statSync(folder).isDirectory()) { const
                    htmlCount=fs.readdirSync(folder).filter(f=> f.endsWith('.html')).length;
                    found.push(`${folder} (${htmlCount} HTML files)`);
                    } else {
                    missing.push(folder);
                    }
                    }

                    if (missing.length > 0) {
                    return {
                    pass: false,
                    message: `Missing critical folders: ${missing.join(', ')}`
                    };
                    }

                    return {
                    pass: true,
                    message: `All required folders exist: ${found.join(', ')}`
                    };
                    }

                    function testRelativePathsWork() {
                    const issues = [];
                    const foldersToTest = ['industries', 'agents', 'partners'];

                    for (const folder of foldersToTest) {
                    if (fs.existsSync(folder)) {
                    const relativePath = path.join(folder, '..', 'content', 'content.json');
                    if (!fs.existsSync(relativePath)) {
                    issues.push(`From ${folder}/ to content.json is broken`);
                    }
                    }
                    }

                    if (issues.length > 0) {
                    return {
                    pass: false,
                    message: issues.join('; ')
                    };
                    }

                    return {
                    pass: true,
                    message: 'All relative paths work correctly'
                    };
                    }

                    function testDeploymentStructure() {
                    const required = ['content', 'industries', 'agents'];
                    const missing = required.filter(f => !fs.existsSync(f));

                    if (missing.length > 0) {
                    return {
                    pass: false,
                    message: `Missing required for deployment: ${missing.join(', ')}`
                    };
                    }

                    // Check for index.html
                    if (!fs.existsSync('index.html')) {
                    return {
                    pass: true,
                    warning: true,
                    message: 'Deployment structure valid (index.html recommended but not required)'
                    };
                    }

                    return {
                    pass: true,
                    message: 'Deployment structure is complete'
                    };
                    }

                    // ===== JSON TESTS =====

                    function testContentJsonExists() {
                    try {
                    if (!fs.existsSync(config.contentJsonPath)) {
                    return { pass: false, message: `File not found: ${config.contentJsonPath}` };
                    }
                    const content = fs.readFileSync(config.contentJsonPath, 'utf8');
                    contentData = JSON.parse(content);
                    return { pass: true, message: `Found at: ${config.contentJsonPath}` };
                    } catch (error) {
                    return { pass: false, message: error.message };
                    }
                    }

                    function testJsonValid() {
                    if (!contentData) {
                    return { pass: false, message: 'No JSON data loaded' };
                    }
                    try {
                    JSON.stringify(contentData);
                    return { pass: true, message: 'JSON is valid' };
                    } catch (error) {
                    return { pass: false, message: `JSON error: ${error.message}` };
                    }
                    }

                    function testIndustryPagesMatchJson() {
                    if (!contentData || !contentData.industries) {
                    return { pass: false, message: 'No industries in JSON' };
                    }

                    const issues = [];

                    for (const [industryName, industryData] of Object.entries(contentData.industries)) {
                    const htmlPath = `industries/${industryName}.html`;
                    if (!fs.existsSync(htmlPath)) {
                    issues.push(`${industryName} in JSON but missing HTML at ${htmlPath}`);
                    }
                    }

                    if (issues.length > 0) {
                    return {
                    pass: false,
                    message: issues.join('; ')
                    };
                    }

                    return {
                    pass: true,
                    message: 'All industries in JSON have matching HTML files'
                    };
                    }

                    function testIndustryFields() {
                    if (!contentData || !contentData.industries) {
                    return { pass: false, message: 'No industries data' };
                    }
                    const issues = [];
                    for (const [industryName, industryData] of Object.entries(contentData.industries)) {
                    for (const field of config.criticalFields.industry) {
                    if (!industryData[field] || industryData[field].trim() === '') {
                    issues.push(`${industryName}.${field}`);
                    }
                    }
                    }
                    if (issues.length > 0) {
                    return {
                    pass: false,
                    message: `Missing fields: ${issues.slice(0, 3).join(', ')}${issues.length > 3 ? ` (+${issues.length
                    - 3} more)` : ''}`,
                    warning: issues.length < 3 }; } return { pass: true, message: 'All critical fields present' }; }
                        //=====TEST CATEGORIES=====const testCategories=[ { name: 'Folder Structure Tests' , quick:
                        true, tests: [ { name: 'Required folders exist' , fn: testRequiredFoldersExist }, {
                        name: 'Relative paths work correctly' , fn: testRelativePathsWork }, {
                        name: 'Deployment structure is valid' , fn: testDeploymentStructure } ] }, {
                        name: 'Agents Folder Tests' , quick: true, tests: [ { name: 'Agents HTML files exist' , fn:
                        testAgentsHtmlFilesExist }, { name: 'All agents HTML files are valid' , fn:
                        testAllAgentsFilesValid } ] }, { name: 'Industries Folder Tests' , quick: true, tests: [ {
                        name: 'Industries HTML files exist' , fn: testIndustriesHtmlFilesExist }, {
                        name: 'All industries HTML files are valid' , fn: testAllIndustriesFilesValid } ] }, {
                        name: 'Partners Folder Tests (NEW)' , quick: true, tests: [ { name: 'Partners folder exists' ,
                        fn: testPartnersFolder }, { name: 'All partner HTML files are valid' , fn:
                        testPartnersHtmlFilesValid }, { name: 'Ray White page exists' , fn: testRayWhitePageExists } ]
                        }, { name: 'JSON & Integration Tests' , quick: true, tests: [ {
                        name: 'content.json exists and loads' , fn: testContentJsonExists }, { name: 'JSON is valid' ,
                        fn: testJsonValid }, { name: 'Partners section exists in JSON' , fn: testPartnersInContentJson
                        }, { name: 'Ray White in content.json' , fn: testRayWhiteInContentJson }, {
                        name: 'Partner fields are complete' , fn: testPartnerFields }, {
                        name: 'Industry pages match JSON' , fn: testIndustryPagesMatchJson }, {
                        name: 'Industry fields are complete' , fn: testIndustryFields } ] } ]; //=====TEST
                        RUNNER=====function runTests(quickOnly=false) { printHeader(); const categoriesToRun=quickOnly ?
                        testCategories.filter(cat=> cat.quick)
                        : testCategories;

                        for (const category of categoriesToRun) {
                        printCategoryHeader(category.name);

                        for (const test of category.tests) {
                        testResults.total++;
                        const result = test.fn();

                        printTestResult(test.name, result);

                        if (!result.pass) {
                        if (result.warning) {
                        testResults.warnings++;
                        } else {
                        testResults.failed++;
                        }
                        } else {
                        if (result.warning) {
                        testResults.warnings++;
                        } else {
                        testResults.passed++;
                        }
                        }
                        }
                        }

                        const exitCode = printSummary();
                        return exitCode;
                        }

                        // ===== MAIN =====

                        const args = process.argv.slice(2);
                        const quickOnly = args.includes('--quick');

                        const exitCode = runTests(quickOnly);
                        process.exit(exitCode);